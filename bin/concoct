#!/usr/bin/env python
from __future__ import division

import sys
import logging
import vbgmm
import numpy as np 

from sklearn.cluster import KMeans

from concoct.output import Output
from concoct.parser import arguments
from concoct.cluster import cluster
from concoct.input import load_data
from concoct.transform import perform_pca
from concoct.processes import prll_map

def vbgmm_fit_wrapper(args):
    return vbgmm.fit(*args)

def main(args):
    # Initialize output handling
    Output(args.basename,args)

    composition, cov, cov_range = load_data(args)

    # If there are zero or one contig that exceed the filter, do not continue
    if len(composition) < 2:
        logging.error('Not enough contigs pass the threshold filter. Exiting!')
        sys.exit(-1)
    
    if cov is not None:
        joined = composition.join(cov.ix[:,cov_range[0]:cov_range[1]],how="inner")
    else:
        joined = composition

    # Fix special case in pca_components
    if args.pca_components == "All":
        args.pca_components = joined[args.length_threshold_filter].shape[1]

    #PCA on the contigs that have kmer count greater than length_threshold
    transform_filter, pca = perform_pca(
        joined,
        args.pca_components
        )

    logging.info('Performed PCA, resulted in %s dimensions' % transform_filter.shape[1])
    
    if not args.no_original_data:
        Output.write_original_data(
            joined,
            args.length_threshold
            )

    Output.write_pca(
        transform_filter,
        args.length_threshold,
        joined.index,
        )

    Output.write_pca_components(
        pca.components_,
        args.length_threshold
        )

    logging.info('PCA transformed data.')

    logging.info('Will call vbgmm with parameters: %s, %s, %s' % (Output.CONCOCT_PATH, args.clusters, args.length_threshold))
    NC = transform_filter.shape[0]
    assign = np.zeros(NC,dtype=np.int32)
    debug=False
    
    nSplit=4
    kmeans = KMeans(init='k-means++', n_clusters=nSplit, n_init=10)
    kmeans.fit(transform_filter)
    labels = kmeans.labels_
    
    fit_arguments = []
    
    l = 0
    for s in range(nSplit):
        transform_S = np.copy(transform_filter[labels==s,],order='C')
        
        NS=transform_S.shape[0]
        
        #assign_S = np.zeros(NS,dtype=np.int32)
    
        fit_arguments.append([transform_S, args.clusters, debug])
        
    assigns = prll_map(vbgmm_fit_wrapper, fit_arguments)
    
    for s in range(nSplit):
        #[transform_S, assign_S, args.clusters, debug] = fit_arguments[s]
        assign_S = assigns[s]       
        map_S = np.where(labels==s)
        
        setS = sorted(list(set(assign_S)))
        mapS = {}
        for a in setS:
            mapS[a] = l
            l = l + 1 
        
        n = 0
        for m in np.nditer(map_S):
            assign[m] = mapS[assign_S[n]]
            n=n+1
    
    Output.write_assign(
        assign,
        args.length_threshold,
        joined.index,
        )

#    vbgmm.fit(Output.CONCOCT_PATH, args.clusters, args.length_threshold,args.seed,args.iterations,args.epsilon,args.converge_out)

    logging.info("CONCOCT Finished")

        
if __name__=="__main__":
    args = arguments()
    if args.total_percentage_pca == 100:
        args.pca_components = "All"
    else:
        args.pca_components = args.total_percentage_pca/100.0

    results = main(args)

    print >> sys.stderr, "CONCOCT Finished, the log shows how it went."
